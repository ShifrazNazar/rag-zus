---
alwaysApply: true
---

# Mindhive AI Chatbot - Cursor Guidelines

## Project Overview

Multi-agent chatbot with RAG, Text2SQL, tool calling, and custom React frontend. Built for Mindhive technical assessment.

## Tech Stack

- **Backend**: FastAPI, LangChain, FAISS, SQLite, OpenAI/Anthropic API
- **Frontend**: React (Vite), TypeScript, TailwindCSS, shadcn/ui (Radix UI), localStorage
- **Testing**: pytest (backend), vitest (frontend), @testing-library/react
- **Deployment**: Backend on Railway/Render, Frontend on Vercel
- **Containerization**: Docker, Docker Compose

## Project Structure

```
mindhive-chatbot/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ main.py                 # FastAPI app entry with CORS, global exception handler
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â”œâ”€â”€ Dockerfile              # Backend containerization with health check
â”‚   â”œâ”€â”€ README.md               # Backend-specific documentation
â”‚   â”œâ”€â”€ pytest.ini              # Pytest configuration with coverage settings
â”‚   â”œâ”€â”€ routers/
â”‚   â”‚   â”œâ”€â”€ calculator.py       # POST /calculate
â”‚   â”‚   â”œâ”€â”€ products.py         # GET /products?query=<text>
â”‚   â”‚   â”œâ”€â”€ outlets.py          # GET /outlets?query=<nl>
â”‚   â”‚   â””â”€â”€ chat.py             # POST /chat (main agent endpoint)
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ agent_planner.py    # Intent parsing, action selection
â”‚   â”‚   â”œâ”€â”€ memory_manager.py   # Conversation state tracking
â”‚   â”‚   â”œâ”€â”€ rag_service.py      # Vector store + retrieval
â”‚   â”‚   â”œâ”€â”€ text2sql_service.py # NL to SQL translation
â”‚   â”‚   â””â”€â”€ tool_executor.py    # Tool call wrapper with error handling
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ schemas.py          # Pydantic models
â”‚   â”‚   â””â”€â”€ database.py         # SQLite connection
â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â”œâ”€â”€ outlets.db          # SQLite database
â”‚   â”‚   â”œâ”€â”€ products/           # Scraped product data
â”‚   â”‚   â””â”€â”€ faiss_index/        # Vector store files
â”‚   â”œâ”€â”€ scripts/
â”‚   â”‚   â”œâ”€â”€ scrape_products.py  # Scrape shop.zuscoffee.com drinkware
â”‚   â”‚   â””â”€â”€ scrape_outlets.py   # Scrape zuscoffee.com outlets
â”‚   â””â”€â”€ tests/
â”‚       â”œâ”€â”€ test_calculator.py
â”‚       â”œâ”€â”€ test_products.py
â”‚       â”œâ”€â”€ test_outlets.py
â”‚       â””â”€â”€ test_agent.py
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ ChatWindow.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ MessageList.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ MessageBubble.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ InputComposer.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ QuickActions.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ ToolCallCard.tsx  # Expandable tool call visualization
â”‚   â”‚   â”‚   â”œâ”€â”€ BackendStatus.tsx  # Health check status indicator
â”‚   â”‚   â”‚   â”œâ”€â”€ ErrorBoundary.tsx # Error boundary wrapper
â”‚   â”‚   â”‚   â””â”€â”€ ui/               # shadcn/ui components
â”‚   â”‚   â”‚       â”œâ”€â”€ button.tsx
â”‚   â”‚   â”‚       â”œâ”€â”€ card.tsx
â”‚   â”‚   â”‚       â”œâ”€â”€ input.tsx
â”‚   â”‚   â”‚       â”œâ”€â”€ textarea.tsx
â”‚   â”‚   â”‚       â””â”€â”€ alert.tsx
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â””â”€â”€ useChat.ts       # Chat state management
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â””â”€â”€ api.ts           # Backend API calls with TypeScript types
â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”‚   â””â”€â”€ localStorage.ts  # Persistence helper
â”‚   â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”‚   â””â”€â”€ utils.ts         # Utility functions (cn for className merging)
â”‚   â”‚   â”œâ”€â”€ test/
â”‚   â”‚   â”‚   â””â”€â”€ setup.ts         # Vitest setup with testing-library
â”‚   â”‚   â”œâ”€â”€ App.tsx
â”‚   â”‚   â””â”€â”€ main.tsx
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ Dockerfile               # Frontend containerization
â”‚   â”œâ”€â”€ vite.config.ts
â”‚   â”œâ”€â”€ vitest.config.ts         # Vitest configuration
â”‚   â”œâ”€â”€ eslint.config.js         # ESLint configuration
â”‚   â”œâ”€â”€ postcss.config.js        # PostCSS configuration
â”‚   â”œâ”€â”€ tailwind.config.js       # Tailwind with dark mode and animations
â”‚   â”œâ”€â”€ tsconfig.json            # TypeScript configuration
â”‚   â”œâ”€â”€ tsconfig.app.json        # TypeScript app config
â”‚   â””â”€â”€ tsconfig.node.json       # TypeScript node config
â”œâ”€â”€ README.md
â””â”€â”€ docker-compose.yml           # Full stack Docker setup with health checks
```

## Code Style & Conventions

### Python (Backend)

- Use type hints everywhere: `def calculate(expression: str) -> dict[str, Any]:`
- Async/await for all I/O operations
- Pydantic for request/response validation
- Error handling: Always return structured JSON errors, never raise unhandled exceptions
- Logging: Use `logging` module, INFO for actions, ERROR for failures
- Naming: snake_case for functions/variables, PascalCase for classes
- Max line length: 100 characters
- Docstrings: Google style for all public functions

### TypeScript (Frontend)

- **TypeScript is required** - All frontend code uses TypeScript (.tsx, .ts)
- Functional components with hooks only (no class components)
- Type definitions for all API responses and component props
- Naming: camelCase for functions/variables, PascalCase for components
- Props: Destructure in function signature with TypeScript interfaces
- State: Use useState for local, context for global
- API calls: Centralize in `services/api.ts` with typed interfaces
- Error boundaries: Wrap main app and chat components
- Utility functions: Use `lib/utils.ts` for className merging (cn function)

### Git Commits

- Format: `[module] action: description`
- Examples:
  - `[backend] feat: add calculator endpoint with error handling`
  - `[frontend] fix: prevent message duplication on refresh`
  - `[scraper] chore: update outlet scraping selectors`

## Development Workflow

### Phase 1: Backend Foundation

1. **Setup FastAPI project**

   - Install: `fastapi uvicorn langchain openai faiss-cpu sqlalchemy pydantic`
   - Create `.env` with `OPENAI_API_KEY=xxx` or `ANTHROPIC_API_KEY=xxx`
   - Configure CORS middleware for frontend integration
   - Add global exception handler for structured error responses
   - Test server: `uvicorn main:app --reload`

2. **Build Calculator API**

   - Endpoint: `POST /calculate`
   - Body: `{"expression": "2 + 2"}`
   - Use `ast.literal_eval` for safe parsing (no `eval()`)
   - Return: `{"result": 4}` or `{"error": "Invalid expression"}`
   - Test cases: valid math, malformed input, division by zero

3. **Scrape ZUS Data**

   - Products: https://shop.zuscoffee.com/ (drinkware only)
   - Outlets: https://zuscoffee.com/category/store/kuala-lumpur-selangor/
   - Save products as JSON, outlets in SQLite
   - Schema: `outlets(id, name, location, district, hours, services, lat, lon)`

4. **Products RAG Endpoint**

   - Chunk product descriptions (500 chars)
   - Embed with `sentence-transformers` or OpenAI
   - Store in FAISS
   - Endpoint: `GET /products?query=tumbler`
   - Return top-3 results + LLM summary
   - Error: Empty query returns 400, no results returns empty list

5. **Outlets Text2SQL Endpoint**

   - Endpoint: `GET /outlets?query=outlets in petaling jaya`
   - Use LangChain `SQLDatabaseChain` or custom prompt
   - Sanitize: Whitelist SELECT, block DROP/DELETE/UPDATE
   - Execute query, return JSON results
   - Error: Log SQL injection attempts, return sanitized error

6. **Health Check Endpoint**

   - Endpoint: `GET /health` for deployment monitoring
   - Returns: `{"status": "healthy", "service": "mindhive-chatbot"}`
   - Used by Docker health checks and frontend status indicator

7. **Root Endpoint**
   - Endpoint: `GET /` for API information
   - Returns: `{"message": "Mindhive AI Chatbot API", "status": "running"}`

### Phase 2: Agent Core

1. **Memory System**

   - Use LangChain `ConversationBufferMemory`
   - Track slots: `outlet_name`, `product_interest`, `calculation_pending`
   - Persist in session (Redis optional, dict for MVP)

2. **Agent Planner**

   ```python
   class AgentPlanner:
       def analyze_intent(self, user_input: str, memory: dict) -> dict:
           # Use LLM to classify: calculator, product_search, outlet_query, chat
           # Return: {"intent": "calculator", "missing_slots": ["expression"]}

       def select_action(self, intent: str, slots: dict) -> str:
           # Return: "ask_clarification", "call_calculator", "call_products", etc.

       def execute_action(self, action: str, params: dict) -> dict:
           # Call tool, update memory, return response
   ```

3. **Tool Integration**

   - Wrapper functions for each API with error handling

4. **Unhappy Flow Handling**
   - Missing params: Ask clarifying question ("What would you like to calculate?")
   - API down: Return friendly error ("Calculator is temporarily unavailable")
   - Malicious input: Sanitize and log, return error message

### Phase 3: Frontend

1. **React Setup**

   - `npm create vite@latest frontend -- --template react-ts` (TypeScript template)
   - Install: `tailwindcss lucide-react @radix-ui/react-slot clsx tailwind-merge class-variance-authority tailwindcss-animate`
   - Install testing: `vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom`
   - Configure Tailwind in `tailwind.config.js` with dark mode and animations
   - Configure Vitest in `vitest.config.ts` with jsdom environment
   - Setup test utilities in `src/test/setup.ts`
   - Configure ESLint in `eslint.config.js`
   - Configure PostCSS in `postcss.config.js`

2. **Chat Components**

   - `ChatWindow`: Main chat container with ErrorBoundary wrapper
   - `MessageBubble`: Avatar, timestamp, message content, loading indicator
   - `InputComposer`: Multiline textarea, Enter to send, Shift+Enter for newline
   - `QuickActions`: Dropdown for `/calc`, `/products`, `/outlets`, `/reset`
   - `MessageList`: Auto-scroll to bottom
   - `ToolCallCard`: Expandable card showing tool calls with input/output, success/error states
   - `BackendStatus`: Health check indicator with periodic polling (30s interval)
   - `ErrorBoundary`: Catches React errors and displays fallback UI
   - **UI Components** (shadcn/ui): `Button`, `Card`, `Input`, `Textarea`, `Alert` - Radix UI based

3. **API Integration**

   - `api.ts`: TypeScript service with typed interfaces
   - Functions: `sendMessage()`, `calculate()`, `searchProducts()`, `searchOutlets()`, `checkHealth()`
   - Calls backend endpoints: `/chat`, `/calculate`, `/products`, `/outlets`, `/health`
   - Environment variable: `VITE_API_URL` (defaults to `http://localhost:8000`)
   - Handles errors gracefully with typed error responses
   - All functions return typed Promise responses

4. **Persistence**

   - Save `chatHistory` to localStorage after each message
   - Load on mount, clear on `/reset`
   - Format: `[{role: 'user'|'bot', content: string, timestamp: ISO8601}]`

5. **Agent Visualization**

   - Show loading states: "ðŸ” Searching products..." "ðŸ§® Calculating..."
   - Display tool calls as expandable cards via `ToolCallCard` component
   - Highlight errors in red, success in green with color-coded borders
   - Show tool icons (Calculator, ShoppingBag, MapPin) and status badges
   - Expandable JSON view of tool inputs and outputs

6. **Backend Status Monitoring**
   - `BackendStatus` component polls `/health` endpoint every 30 seconds
   - Visual indicator (green checkmark/red X) with connection status
   - Responsive: hides text on small screens, shows icon only

### Phase 4: Testing & Documentation

1. **Backend Tests**

   - pytest for all endpoints (configured in `pytest.ini`)
   - Coverage configuration: pytest-cov with 80% threshold
   - Coverage reports: term-missing, html, xml
   - Mock external APIs (LLM, embeddings)
   - Test unhappy paths: missing params, timeouts, malicious input
   - Coverage target: >80%
   - Run tests: `pytest tests/ -v` or `pytest --cov=. --cov-report=html`

2. **Frontend Tests**

   - Vitest for components (configured in `vitest.config.ts`)
   - Testing Library: `@testing-library/react`, `@testing-library/jest-dom`, `@testing-library/user-event`
   - Test setup: `src/test/setup.ts` with cleanup after each test
   - Test user interactions: sending messages, quick actions, persistence
   - Component tests: `InputComposer.test.tsx`, `MessageBubble.test.tsx`
   - Snapshot tests for UI consistency (5 snapshots)
   - Coverage configuration: v8 provider with 80% thresholds (lines, functions, branches, statements)
   - Coverage reports: text, json, html
   - Test scripts: `npm test`, `npm run test:ui`, `npm run test:coverage`

3. **Documentation**
   - README: Setup instructions, trade-offs
   - API docs: FastAPI auto-generates at `/docs`

## Critical Rules

### Security

- **NEVER** use `eval()` for calculator, use `ast.literal_eval`
- **ALWAYS** sanitize SQL queries (parameterized queries only)
- **NEVER** expose API keys in frontend code
- **ALWAYS** validate input on backend (Pydantic models)

### Performance

- **ALWAYS** use async/await for I/O operations

### Error Handling

- **NEVER** crash on user input, always return structured error
- **ALWAYS** log errors with context (timestamp, input)
- **NEVER** expose internal errors to user (sanitize stack traces)

### Memory Management

- **ALWAYS** include conversation history in context window
- **RESET** memory on `/reset` command
- **PERSIST** memory across page refreshes (localStorage)

## Testing Checklist

- [ ] Calculator: Valid math, malformed input, division by zero
- [ ] Products: Valid query, empty query, no results, API timeout
- [ ] Outlets: Valid query, SQL injection attempt, API down
- [ ] Agent: Multi-turn context, slot filling, action selection
- [ ] Frontend: Message send, persistence, quick actions, error display

## Deployment Checklist

- [ ] Docker Compose for local development with health checks
- [ ] Backend Dockerfile with health check configuration
- [ ] Frontend Dockerfile for containerization
- [ ] Backend deployed to Railway/Render with health check endpoint
- [ ] Frontend deployed to Vercel with `VITE_API_URL` env variable
- [ ] README has live demo link and setup instructions
- [ ] Backend README.md with API documentation
- [ ] All tests passing in CI/CD pipeline

## Common Pitfalls to Avoid

1. **Forgetting to handle async properly**: Always await API calls
2. **Not testing unhappy paths**: Test failures as much as successes
3. **Exposing secrets**: Use .env, never commit keys
4. **Poor error messages**: Be specific ("Missing outlet name") not generic ("Error occurred")
5. **Not persisting chat**: Users expect history to survive refresh
6. **Ignoring SQL injection**: Always use parameterized queries
7. **No loading indicators**: Users need feedback during async operations
8. **Not handling large conversations**: Keep conversation history manageable

## Resources

- FastAPI docs: https://fastapi.tiangolo.com
- LangChain docs: https://python.langchain.com
- FAISS tutorial: https://github.com/facebookresearch/faiss/wiki
- React hooks: https://react.dev/reference/react
- Tailwind CSS: https://tailwindcss.com/docs

## Decision Log

Track key architectural decisions here:

**Why FAISS over Pinecone?**

- Local-first, no API costs, sufficient for <10k docs, easier testing

**Why SQLite over PostgreSQL?**

- Simpler setup, read-heavy workload, easy to bundle with app

**Why LangChain over custom agent loop?**

- Battle-tested, good abstractions, tool calling built-in, faster development

**Why localStorage over session storage?**

- Persists across tabs/windows, better UX for returning users

**Why TypeScript over JavaScript?**

- Type safety catches errors at compile time, better IDE support, self-documenting code

**Why shadcn/ui over other component libraries?**

- Radix UI primitives for accessibility, Tailwind CSS for styling, copy-paste components (no npm dependency bloat)

**Why Vitest over Jest?**

- Faster, better ESM support, Vite-native, compatible with Jest API

---

## Quick Start Commands

**Backend:**

```bash
cd backend
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate
pip install -r requirements.txt
python scripts/scrape_products.py
python scripts/scrape_outlets.py
uvicorn main:app --reload --port 8000
```

**Frontend:**

```bash
cd frontend
npm install
npm run dev
```

**Tests:**

```bash
# Backend
cd backend && pytest -v

# Frontend
cd frontend && npm test
```

**Full Stack:**

```bash
docker-compose up
```

**Docker Commands:**

```bash
# Build and run with Docker Compose
docker-compose up --build

# Run in detached mode
docker-compose up -d

# View logs
docker-compose logs -f

# Stop services
docker-compose down
```
